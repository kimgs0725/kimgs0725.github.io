---
title: "Command 패턴"
date: 2021-06-28T09:33:09+09:00
draft: true
categories:
- design pattern
tags:
- 디자인패턴
- 자바
---
    
> 커맨더 패턴은 요청 자체를 캡슐화하는 것입니다. 이를 통해 요청이 서로 다른 사용자를 매개변수로 만들고, 요청을 대기시키거나 로깅하며, 되돌릴 수 있는 연산을 지원합니다.

커맨드 패턴은 **요청하는 객체**와 **요청을 수행하는 객체**를 분리해주는 패턴입니다. 요청을 받는 객체는 어떤 객체가 그 요청을 처리해야하는지 모르는 경우가 많습니다. 그래서  요청을 응용 프로그램(사용자)단에서 처리를 해야합니다. 그럼 그 요청을 받는 객체에서는 응용 프로그램에게 어떻게 처리를 넘기게 할까요? 게다가 그 요청이 하나면 하나의 인터페이스만 추가하면 되지만, 요청이 여러개면 처리하기 힘들 것 같습니다. 이 문제를 해결하기 위해 나온 패턴이 **커맨더 패턴**입니다.

![](/images/Command_Design_Pattern_Class_Diagram.png)

요청하는 객체인 Invoker와 요청을 수행하는 Receiver가 존재합니다. Invoker에선 Receiver를 직접 참조하지 않습니다. 대신 중간에 Command를 통해 요청을 캡슐화한 객체가 존재하게 됩니다. 그리고 Command를 구현한 ConcreteCommand 객체에서 Receiver를 참조하게 됩니다. 만약에 클라이언트가 동적으로 요청을 추가하고 싶으면, Command 인터페이스를 구현한 NewConcreteCommand 객체를 생성하여 Invoker에 등록하면 됩니다. 이렇게 클라이언트가 동적으로도 요청을 추가할 수 있게 됩니다.

커맨더 패턴을 잘 설명할 수 있는 예제로 메뉴 인터페이스를 들 수 있습니다.

![](/images/MenuEx.png)

메뉴 안에는 여러 개의 요청이 담겨져 있습니다. 그리고 그 요청마다 어플리케이션에선 다른 수행을 해줘야 하죠. 그런데 응용프로그램 단에서 어떤 요청인지도 모른